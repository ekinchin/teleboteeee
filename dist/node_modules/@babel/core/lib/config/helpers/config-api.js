"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = makeAPI;

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

var _ = require("../../");

var _caching = require("../caching");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

function makeAPI(cache) {
  const env = value => cache.using(data => {
    if (typeof value === "undefined") return data.envName;

    if (typeof value === "function") {
      return (0, _caching.assertSimpleType)(value(data.envName));
    }

    if (!Array.isArray(value)) value = [value];
    return value.some(entry => {
      if (typeof entry !== "string") {
        throw new Error("Unexpected non-string value");
      }

      return entry === data.envName;
    });
  });

  const caller = cb => cache.using(data => (0, _caching.assertSimpleType)(cb(data.caller)));

  return {
    version: _.version,
    cache: cache.simple(),
    env,
    async: () => false,
    caller,
    assertVersion
  };
}

function assertVersion(range) {
  if (typeof range === "number") {
    if (!Number.isInteger(range)) {
      throw new Error("Expected string or integer value.");
    }

    range = `^${range}.0.0-0`;
  }

  if (typeof range !== "string") {
    throw new Error("Expected string or integer value.");
  }

  if (_semver().default.satisfies(_.version, range)) return;
  const limit = Error.stackTraceLimit;

  if (typeof limit === "number" && limit < 25) {
    Error.stackTraceLimit = 25;
  }

  const err = new Error(`Requires Babel "${range}", but was loaded with "${_.version}". ` + `If you are sure you have a compatible version of @babel/core, ` + `it is likely that something in your build process is loading the ` + `wrong version. Inspect the stack trace of this error to look for ` + `the first entry that doesn't mention "@babel/core" or "babel-core" ` + `to see what is calling Babel.`);

  if (typeof limit === "number") {
    Error.stackTraceLimit = limit;
  }

  throw Object.assign(err, {
    code: "BABEL_VERSION_UNSUPPORTED",
    version: _.version,
    range
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvY29yZS9saWIvY29uZmlnL2hlbHBlcnMvY29uZmlnLWFwaS5qcyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJtYWtlQVBJIiwiX3NlbXZlciIsImRhdGEiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl8iLCJfY2FjaGluZyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJjYWNoZSIsImVudiIsInVzaW5nIiwiZW52TmFtZSIsImFzc2VydFNpbXBsZVR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJzb21lIiwiZW50cnkiLCJFcnJvciIsImNhbGxlciIsImNiIiwidmVyc2lvbiIsInNpbXBsZSIsImFzeW5jIiwiYXNzZXJ0VmVyc2lvbiIsInJhbmdlIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwic2F0aXNmaWVzIiwibGltaXQiLCJzdGFja1RyYWNlTGltaXQiLCJlcnIiLCJhc3NpZ24iLCJjb2RlIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQUEsTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUMzQ0MsRUFBQUEsS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0FELE9BQU8sQ0FBQ0UsT0FBUixHQUFrQkMsT0FBbEI7O0FBRUEsU0FBU0MsT0FBVCxHQUFtQjtBQUNqQixRQUFNQyxJQUFJLEdBQUdDLHNCQUFzQixDQUFDQyxPQUFPLENBQUMsUUFBRCxDQUFSLENBQW5DOztBQUVBSCxFQUFBQSxPQUFPLEdBQUcsWUFBWTtBQUNwQixXQUFPQyxJQUFQO0FBQ0QsR0FGRDs7QUFJQSxTQUFPQSxJQUFQO0FBQ0Q7O0FBRUQsSUFBSUcsQ0FBQyxHQUFHRCxPQUFPLENBQUMsUUFBRCxDQUFmOztBQUVBLElBQUlFLFFBQVEsR0FBR0YsT0FBTyxDQUFDLFlBQUQsQ0FBdEI7O0FBRUEs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LENBQUNZLGVBQU4sR0FBd0JELEtBQXhCO0FBQ0Q7O0FBRUQsUUFBTWxDLE1BQU0sQ0FBQ3FDLE1BQVAsQ0FBY0QsR0FBZCxFQUFtQjtBQUN2QkUsSUFBQUEsSUFBSSxFQUFFLDJCQURpQjtBQUV2QlosSUFBQUEsT0FBTyxFQUFFaEIsQ0FBQyxDQUFDZ0IsT0FGWTtBQUd2QkksSUFBQUE7QUFIdUIsR0FBbkIsQ0FBTjtBQUtEIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBtYWtlQVBJO1xuXG5mdW5jdGlvbiBfc2VtdmVyKCkge1xuICBjb25zdCBkYXRhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwic2VtdmVyXCIpKTtcblxuICBfc2VtdmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi8uLi9cIik7XG5cbnZhciBfY2FjaGluZyA9IHJlcXVpcmUoXCIuLi9jYWNoaW5nXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBtYWtlQVBJKGNhY2hlKSB7XG4gIGNvbnN0IGVudiA9IHZhbHVlID0+IGNhY2hlLnVzaW5nKGRhdGEgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBkYXRhLmVudk5hbWU7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiAoMCwgX2NhY2hpbmcuYXNzZXJ0U2ltcGxlVHlwZSkodmFsdWUoZGF0YS5lbnZOYW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgdmFsdWUgPSBbdmFsdWVdO1xuICAgIHJldHVybiB2YWx1ZS5zb21lKGVudHJ5ID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBub24tc3RyaW5nIHZhbHVlXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW50cnkgPT09IGRhdGEuZW52TmFtZTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgY29uc3QgY2FsbGVyID0gY2IgPT4gY2FjaGUudXNpbmcoZGF0YSA9PiAoMCwgX2NhY2hpbmcuYXNzZXJ0U2ltcGxlVHlwZSkoY2IoZGF0YS5jYWxsZXIpKSk7XG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiBfLnZlcnNpb24sXG4gICAgY2FjaGU6IGNhY2hlLnNpbXBsZSgpLFxuICAgIGVudixcbiAgICBhc3luYzogKCkgPT4gZmFsc2UsXG4gICAgY2FsbGVyLFxuICAgIGFzc2VydFZlcnNpb25cbiAgfTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmVyc2lvbihyYW5nZSkge1xuICBpZiAodHlwZW9mIHJhbmdlID09PSBcIm51bWJlclwiKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHJhbmdlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIG9yIGludGVnZXIgdmFsdWUuXCIpO1xuICAgIH1cblxuICAgIHJhbmdlID0gYF4ke3JhbmdlfS4wLjAtMGA7XG4gIH1cblxuICBpZiAodHlwZW9mIHJhbmdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIG9yIGludGVnZXIgdmFsdWUuXCIpO1xuICB9XG5cbiAgaWYgKF9zZW12ZXIoKS5kZWZhdWx0LnNhdGlzZmllcyhfLnZlcnNpb24sIHJhbmdlKSkgcmV0dXJuO1xuICBjb25zdCBsaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcblxuICBpZiAodHlwZW9mIGxpbWl0ID09PSBcIm51bWJlclwiICYmIGxpbWl0IDwgMjUpIHtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAyNTtcbiAgfVxuXG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgUmVxdWlyZXMgQmFiZWwgXCIke3JhbmdlfVwiLCBidXQgd2FzIGxvYWRlZCB3aXRoIFwiJHtfLnZlcnNpb259XCIuIGAgKyBgSWYgeW91IGFyZSBzdXJlIHlvdSBoYXZlIGEgY29tcGF0aWJsZSB2ZXJzaW9uIG9mIEBiYWJlbC9jb3JlLCBgICsgYGl0IGlzIGxpa2VseSB0aGF0IHNvbWV0aGluZyBpbiB5b3VyIGJ1aWxkIHByb2Nlc3MgaXMgbG9hZGluZyB0aGUgYCArIGB3cm9uZyB2ZXJzaW9uLiBJbnNwZWN0IHRoZSBzdGFjayB0cmFjZSBvZiB0aGlzIGVycm9yIHRvIGxvb2sgZm9yIGAgKyBgdGhlIGZpcnN0IGVudHJ5IHRoYXQgZG9lc24ndCBtZW50aW9uIFwiQGJhYmVsL2NvcmVcIiBvciBcImJhYmVsLWNvcmVcIiBgICsgYHRvIHNlZSB3aGF0IGlzIGNhbGxpbmcgQmFiZWwuYCk7XG5cbiAgaWYgKHR5cGVvZiBsaW1pdCA9PT0gXCJudW1iZXJcIikge1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICB9XG5cbiAgdGhyb3cgT2JqZWN0LmFzc2lnbihlcnIsIHtcbiAgICBjb2RlOiBcIkJBQkVMX1ZFUlNJT05fVU5TVVBQT1JURURcIixcbiAgICB2ZXJzaW9uOiBfLnZlcnNpb24sXG4gICAgcmFuZ2VcbiAgfSk7XG59Il19