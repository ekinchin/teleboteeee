"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findConfigUpwards = findConfigUpwards;
exports.findRelativeConfig = findRelativeConfig;
exports.findRootConfig = findRootConfig;
exports.loadConfig = loadConfig;

function _debug() {
  const data = _interopRequireDefault(require("debug"));

  _debug = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _fs() {
  const data = _interopRequireDefault(require("fs"));

  _fs = function () {
    return data;
  };

  return data;
}

function _json() {
  const data = _interopRequireDefault(require("json5"));

  _json = function () {
    return data;
  };

  return data;
}

function _resolve() {
  const data = _interopRequireDefault(require("resolve"));

  _resolve = function () {
    return data;
  };

  return data;
}

var _caching = require("../caching");

var _configApi = _interopRequireDefault(require("../helpers/config-api"));

var _utils = require("./utils");

var _patternToRegex = _interopRequireDefault(require("../pattern-to-regex"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const debug = (0, _debug().default)("babel:config:loading:files:configuration");
const BABEL_CONFIG_JS_FILENAME = "babel.config.js";
const BABELRC_FILENAME = ".babelrc";
const BABELRC_JS_FILENAME = ".babelrc.js";
const BABELIGNORE_FILENAME = ".babelignore";

function findConfigUpwards(rootDir) {
  let dirname = rootDir;

  while (true) {
    if (_fs().default.existsSync(_path().default.join(dirname, BABEL_CONFIG_JS_FILENAME))) {
      return dirname;
    }

    const nextDir = _path().default.dirname(dirname);

    if (dirname === nextDir) break;
    dirname = nextDir;
  }

  return null;
}

function findRelativeConfig(packageData, envName, caller) {
  let config = null;
  let ignore = null;

  const dirname = _path().default.dirname(packageData.filepath);

  for (const loc of packageData.directories) {
    if (!config) {
      config = [BABELRC_FILENAME, BABELRC_JS_FILENAME].reduce((previousConfig, name) => {
        const filepath = _path().default.join(loc, name);

        const config = readConfig(filepath, envName, caller);

        if (config && previousConfig) {
          throw new Error(`Multiple configuration files found. Please remove one:\n` + ` - ${_path().default.basename(previousConfig.filepath)}\n` + ` - ${name}\n` + `from ${loc}`);
        }

        return config || previousConfig;
      }, null);
      const pkgConfig = packageData.pkg && packageData.pkg.dirname === loc ? packageToBabelConfig(packageData.pkg) : null;

      if (pkgConfig) {
        if (config) {
          throw new Error(`Multiple configuration files found. Please remove one:\n` + ` - ${_path().default.basename(pkgConfig.filepath)}#babel\n` + ` - ${_path().default.basename(config.filepath)}\n` + `from ${loc}`);
        }

        config = pkgConfig;
      }

      if (config) {
        debug("Found configuration %o from %o.", config.filepath, dirname);
      }
    }

    if (!ignore) {
      const ignoreLoc = _path().default.join(loc, BABELIGNORE_FILENAME);

      ignore = readIgnoreConfig(ignoreLoc);

      if (ignore) {
        debug("Found ignore %o from %o.", ignore.filepath, dirname);
      }
    }
  }

  return {
    config,
    ignore
  };
}

function findRootConfig(dirname, envName, caller) {
  const filepath = _path().default.resolve(dirname, BABEL_CONFIG_JS_FILENAME);

  const conf = readConfig(filepath, envName, caller);

  if (conf) {
    debug("Found root config %o in $o.", BABEL_CONFIG_JS_FILENAME, dirname);
  }

  return conf;
}

function loadConfig(name, dirname, envName, caller) {
  const filepath = _resolve().default.sync(name, {
    basedir: dirname
  });

  const conf = readConfig(filepath, envName, caller);

  if (!conf) {
    throw new Error(`Config file ${filepath} contains no configuration data`);
  }

  debug("Loaded config %o from $o.", name, dirname);
  return conf;
}

function readConfig(filepath, envName, caller) {
  return _path().default.extname(filepath) === ".js" ? readConfigJS(filepath, {
    envName,
    caller
  }) : readConfigJSON5(filepath);
}

const LOADING_CONFIGS = new Set();
const readConfigJS = (0, _caching.makeStrongCache)((filepath, cache) => {
  if (!_fs().default.existsSync(filepath)) {
    cache.forever();
    return null;
  }

  if (LOADING_CONFIGS.has(filepath)) {
    cache.never();
    debug("Auto-ignoring usage of config %o.", filepath);
    return {
      filepath,
      dirname: _path().default.dirname(filepath),
      options: {}
    };
  }

  let options;

  try {
    LOADING_CONFIGS.add(filepath);

    const configModule = require(filepath);

    options = configModule && configModule.__esModule ? configModule.default || undefined : configModule;
  } catch (err) {
    err.message = `${filepath}: Error while loading config - ${err.message}`;
    throw err;
  } finally {
    LOADING_CONFIGS.delete(filepath);
  }

  if (typeof options === "function") {
    options = options((0, _configApi.default)(cache));
    if (!cache.configured()) throwConfigError();
  }

  if (!options || typeof options !== "object" || Array.isArray(options)) {
    throw new Error(`${filepath}: Configuration should be an exported JavaScript object.`);
  }

  if (typeof options.then === "function") {
    throw new Error(`You appear to be using an async configuration, ` + `which your current version of Babel does not support. ` + `We may add support for this in the future, ` + `but if you're on the most recent version of @babel/core and still ` + `seeing this error, then you'll need to synchronously return your config.`);
  }

  return {
    filepath,
    dirname: _path().default.dirname(filepath),
    options
  };
});
const packageToBabelConfig = (0, _caching.makeWeakCache)(file => {
  const babel = file.options["babel"];
  if (typeof babel === "undefined") return null;

  if (typeof babel !== "object" || Array.isArray(babel) || babel === null) {
    throw new Error(`${file.filepath}: .babel property must be an object`);
  }

  return {
    filepath: file.filepath,
    dirname: file.dirname,
    options: babel
  };
});
const readConfigJSON5 = (0, _utils.makeStaticFileCache)((filepath, content) => {
  let options;

  try {
    options = _json().default.parse(content);
  } catch (err) {
    err.message = `${filepath}: Error while parsing config - ${err.message}`;
    throw err;
  }

  if (!options) throw new Error(`${filepath}: No config detected`);

  if (typeof options !== "object") {
    throw new Error(`${filepath}: Config returned typeof ${typeof options}`);
  }

  if (Array.isArray(options)) {
    throw new Error(`${filepath}: Expected config object but found array`);
  }

  return {
    filepath,
    dirname: _path().default.dirname(filepath),
    options
  };
});
const readIgnoreConfig = (0, _utils.makeStaticFileCache)((filepath, content) => {
  const ignoreDir = _path().default.dirname(filepath);

  const ignorePatterns = content.split("\n").map(line => line.replace(/#(.*?)$/, "").trim()).filter(line => !!line);

  for (const pattern of ignorePatterns) {
    if (pattern[0] === "!") {
      throw new Error(`Negation of file paths is not supported.`);
    }
  }

  return {
    filepath,
    dirname: _path().default.dirname(filepath),
    ignore: ignorePatterns.map(pattern => (0, _patternToRegex.default)(pattern, ignoreDir))
  };
});

function throwConfigError() {
  throw new Error(`\
Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvY29yZS9saWIvY29uZmlnL2ZpbGVzL2NvbmZpZ3VyYXRpb24uanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJmaW5kQ29uZmlnVXB3YXJkcyIsImZpbmRSZWxhdGl2ZUNvbmZpZyIsImZpbmRSb290Q29uZmlnIiwibG9hZENvbmZpZyIsIl9kZWJ1ZyIsImRhdGEiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwicmVxdWlyZSIsIl9wYXRoIiwiX2ZzIiwiX2pzb24iLCJfcmVzb2x2ZSIsIl9jYWNoaW5nIiwiX2NvbmZpZ0FwaSIsIl91dGlscyIsIl9wYXR0ZXJuVG9SZWdleCIsIm9iaiIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiZGVidWciLCJCQUJFTF9DT05GSUdfSlNfRklMRU5BTUUiLCJCQUJFTFJDX0ZJTEVOQU1FIiwiQkFCRUxSQ19KU19GSUxFTkFNRSIsIkJBQkVMSUdOT1JFX0ZJTEVOQU1FIiwicm9vdERpciIsImRpcm5hbWUiLCJleGlzdHNTeW5jIiwiam9pbiIsIm5leHREaXIiLCJwYWNrYWdlRGF0YSIsImVudk5hbWUiLCJjYWxsZXIiLCJjb25maWciLCJpZ25vcmUiLCJmaWxlcGF0aCIsImxvYyIsImRpcmVjdG9yaWVzIiwicmVkdWNlIiwicHJldmlvdXNDb25maWciLCJuYW1lIiwicmVhZENvbmZpZyIsIkVycm9yIiwiYmFzZW5hbWUiLCJwa2dDb25maWciLCJwa2ciLCJwYWNrYWdlVG9CYWJlbENvbmZpZyIsImlnbm9yZUxvYyIsInJlYWRJZ25vcmVDb25maWciLCJyZXNvbHZlIiwiY29uZiIsInN5bmMiLCJiYXNlZGlyIiwiZXh0bmFtZSIsInJlYWRDb25maWdKUyIsInJlYWRDb25maWdKU09ONSIsIkxPQURJTkdfQ09ORklHUyIsIlNldCIsIm1ha2VTdHJvbmdDYWNoZSIsImNhY2hlIiwiZm9yZXZlciIsImhhcyIsIm5ldmVyIiwib3B0aW9ucyIsImFkZCIsImNvbmZpZ01vZHVsZSIsInVuZGVmaW5lZCIsImVyciIsIm1lc3NhZ2UiLCJkZWxldGUiLCJjb25maWd1cmVkIiwidGhyb3dDb25maWdFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsInRoZW4iLCJtYWtlV2Vha0NhY2hlIiwiZmlsZSIsImJhYmVsIiwibWFrZVN0YXRpY0ZpbGVDYWNoZSIsImNvbnRlbnQiLCJwYXJzZSIsImlnbm9yZURpciIsImlnbm9yZVBhdHRlcm5zIiwic3BsaXQiLCJtYXAiLCJsaW5lIiwicmVwbGFjZSIsInRyaW0iLCJmaWx0ZXIiLCJwYXR0ZXJuIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQUEsTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUMzQ0MsRUFBQUEsS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0FELE9BQU8sQ0FBQ0UsaUJBQVIsR0FBNEJBLGlCQUE1QjtBQUNBRixPQUFPLENBQUNHLGtCQUFSLEdBQTZCQSxrQkFBN0I7QUFDQUgsT0FBTyxDQUFDSSxjQUFSLEdBQXlCQSxjQUF6QjtBQUNBSixPQUFPLENBQUNLLFVBQVIsR0FBcUJBLFVBQXJCOztBQUVBLFNBQVNDLE1BQVQsR0FBa0I7QUFDaEIsUUFBTUMsSUFBSSxHQUFHQyxzQkFBc0IsQ0FBQ0MsT0FBTyxDQUFDLE9BQUQsQ0FBUixDQUFuQzs7QUFFQUgsRUFBQUEsTUFBTSxHQUFHLFlBQVk7QUFDbkIsV0FBT0MsSUFBUDtBQUNELEdBRkQ7O0FBSUEsU0FBT0EsSUFBUDtBQUNEOztBQUVELFNBQVNHLEtBQVQsR0FBaUI7QUFDZixRQUFNSCxJQUFJLEdBQUdDLHNCQUFzQixDQUFDQyxPQUFPLENBQUMsTUFBRCxDQUFSLENBQW5DOztBQUVBQyxFQUFBQSxLQUFLLEdBQUcsWUFBWTtBQUNsQixXQUFPSCxJQUFQO0FBQ0QsR0FGRDs7QUFJQSxTQUFPQSxJQUFQO0FBQ0Q7O0FBRUQsU0FBU0ksR0FBVCxHQUFlO0FBQ2IsUUFB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QUFYLElBQXNCUCxjQUF0QixFQUFzQztBQUNwQyxRQUFJTyxPQUFPLENBQUMsQ0FBRCxDQUFQLEtBQWUsR0FBbkIsRUFBd0I7QUFDdEIsWUFBTSxJQUFJL0MsS0FBSixDQUFXLDBDQUFYLENBQU47QUFDRDtBQUNGOztBQUVELFNBQU87QUFDTFAsSUFBQUEsUUFESztBQUVMVCxJQUFBQSxPQUFPLEVBQUVqQixLQUFLLEdBQUdVLE9BQVIsQ0FBZ0JPLE9BQWhCLENBQXdCUyxRQUF4QixDQUZKO0FBR0xELElBQUFBLE1BQU0sRUFBRWdELGNBQWMsQ0FBQ0UsR0FBZixDQUFtQkssT0FBTyxJQUFJLENBQUMsR0FBR3pFLGVBQWUsQ0FBQ0csT0FBcEIsRUFBNkJzRSxPQUE3QixFQUFzQ1IsU0FBdEMsQ0FBOUI7QUFISCxHQUFQO0FBS0QsQ0FoQndCLENBQXpCOztBQWtCQSxTQUFTVixnQkFBVCxHQUE0QjtBQUMxQixRQUFNLElBQUk3QixLQUFKLENBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQUFYLENBQU47QUFrQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZmluZENvbmZpZ1Vwd2FyZHMgPSBmaW5kQ29uZmlnVXB3YXJkcztcbmV4cG9ydHMuZmluZFJlbGF0aXZlQ29uZmlnID0gZmluZFJlbGF0aXZlQ29uZmlnO1xuZXhwb3J0cy5maW5kUm9vdENvbmZpZyA9IGZpbmRSb290Q29uZmlnO1xuZXhwb3J0cy5sb2FkQ29uZmlnID0gbG9hZENvbmZpZztcblxuZnVuY3Rpb24gX2RlYnVnKCkge1xuICBjb25zdCBkYXRhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuXG4gIF9kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gX3BhdGgoKSB7XG4gIGNvbnN0IGRhdGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwYXRoXCIpKTtcblxuICBfcGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gX2ZzKCkge1xuICBjb25zdCBkYXRhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZnNcIikpO1xuXG4gIF9mcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gX2pzb24oKSB7XG4gIGNvbnN0IGRhdGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJqc29uNVwiKSk7XG5cbiAgX2pzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlKCkge1xuICBjb25zdCBkYXRhID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVzb2x2ZVwiKSk7XG5cbiAgX3Jlc29sdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbnZhciBfY2FjaGluZyA9IHJlcXVpcmUoXCIuLi9jYWNoaW5nXCIpO1xuXG52YXIgX2NvbmZpZ0FwaSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL2hlbHBlcnMvY29uZmlnLWFwaVwiKSk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxudmFyIF9wYXR0ZXJuVG9SZWdleCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL3BhdHRlcm4tdG8tcmVnZXhcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5jb25zdCBkZWJ1ZyA9ICgwLCBfZGVidWcoKS5kZWZhdWx0KShcImJhYmVsOmNvbmZpZzpsb2FkaW5nOmZpbGVzOmNvbmZpZ3VyYXRpb25cIik7XG5jb25zdCBCQUJFTF9DT05GSUdfSlNfRklMRU5BTUUgPSBcImJhYmVsLmNvbmZpZy5qc1wiO1xuY29uc3QgQkFCRUxSQ19GSUxFTkFNRSA9IFwiLmJhYmVscmNcIjtcbmNvbnN0IEJBQkVMUkNfSlNfRklMRU5BTUUgPSBcIi5iYWJlbHJjLmpzXCI7XG5jb25zdCBCQUJFTElHTk9SRV9GSUxFTkFNRSA9IFwiLmJhYmVsaWdub3JlXCI7XG5cbmZ1bmN0aW9uIGZpbmRDb25maWdVcHdhcmRzKHJvb3REaXIpIHtcbiAgbGV0IGRpcm5hbWUgPSByb290RGlyO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKF9mcygpLmRlZmF1bHQuZXhpc3RzU3luYyhfcGF0aCgpLmRlZmF1bHQuam9pbihkaXJuYW1lLCBCQUJFTF9DT05GSUdfSlNfRklMRU5BTUUpKSkge1xuICAgICAgcmV0dXJuIGRpcm5hbWU7XG4gICAgfVxuXG4gICAgY29uc3QgbmV4dERpciA9IF9wYXRoKCkuZGVmYXVsdC5kaXJuYW1lKGRpcm5hbWUpO1xuXG4gICAgaWYgKGRpcm5hbWUgPT09IG5leHREaXIpIGJyZWFrO1xuICAgIGRpcm5hbWUgPSBuZXh0RGlyO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRSZWxhdGl2ZUNvbmZpZyhwYWNrYWdlRGF0YSwgZW52TmFtZSwgY2FsbGVyKSB7XG4gIGxldCBjb25maWcgPSBudWxsO1xuICBsZXQgaWdub3JlID0gbnVsbDtcblxuICBjb25zdCBkaXJuYW1lID0gX3BhdGgoKS5kZWZhdWx0LmRpcm5hbWUocGFja2FnZURhdGEuZmlsZXBhdGgpO1xuXG4gIGZvciAoY29uc3QgbG9jIG9mIHBhY2thZ2VEYXRhLmRpcmVjdG9yaWVzKSB7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9IFtCQUJFTFJDX0ZJTEVOQU1FLCBCQUJFTFJDX0pTX0ZJTEVOQU1FXS5yZWR1Y2UoKHByZXZpb3VzQ29uZmlnLCBuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVwYXRoID0gX3BhdGgoKS5kZWZhdWx0LmpvaW4obG9jLCBuYW1lKTtcblxuICAgICAgICBjb25zdCBjb25maWcgPSByZWFkQ29uZmlnKGZpbGVwYXRoLCBlbnZOYW1lLCBjYWxsZXIpO1xuXG4gICAgICAgIGlmIChjb25maWcgJiYgcHJldmlvdXNDb25maWcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGxlIGNvbmZpZ3VyYXRpb24gZmlsZXMgZm91bmQuIFBsZWFzZSByZW1vdmUgb25lOlxcbmAgKyBgIC0gJHtfcGF0aCgpLmRlZmF1bHQuYmFzZW5hbWUocHJldmlvdXNDb25maWcuZmlsZXBhdGgpfVxcbmAgKyBgIC0gJHtuYW1lfVxcbmAgKyBgZnJvbSAke2xvY31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWcgfHwgcHJldmlvdXNDb25maWc7XG4gICAgICB9LCBudWxsKTtcbiAgICAgIGNvbnN0IHBrZ0NvbmZpZyA9IHBhY2thZ2VEYXRhLnBrZyAmJiBwYWNrYWdlRGF0YS5wa2cuZGlybmFtZSA9PT0gbG9jID8gcGFja2FnZVRvQmFiZWxDb25maWcocGFja2FnZURhdGEucGtnKSA6IG51bGw7XG5cbiAgICAgIGlmIChwa2dDb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgY29uZmlndXJhdGlvbiBmaWxlcyBmb3VuZC4gUGxlYXNlIHJlbW92ZSBvbmU6XFxuYCArIGAgLSAke19wYXRoKCkuZGVmYXVsdC5iYXNlbmFtZShwa2dDb25maWcuZmlsZXBhdGgpfSNiYWJlbFxcbmAgKyBgIC0gJHtfcGF0aCgpLmRlZmF1bHQuYmFzZW5hbWUoY29uZmlnLmZpbGVwYXRoKX1cXG5gICsgYGZyb20gJHtsb2N9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcgPSBwa2dDb25maWc7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgZGVidWcoXCJGb3VuZCBjb25maWd1cmF0aW9uICVvIGZyb20gJW8uXCIsIGNvbmZpZy5maWxlcGF0aCwgZGlybmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpZ25vcmUpIHtcbiAgICAgIGNvbnN0IGlnbm9yZUxvYyA9IF9wYXRoKCkuZGVmYXVsdC5qb2luKGxvYywgQkFCRUxJR05PUkVfRklMRU5BTUUpO1xuXG4gICAgICBpZ25vcmUgPSByZWFkSWdub3JlQ29uZmlnKGlnbm9yZUxvYyk7XG5cbiAgICAgIGlmIChpZ25vcmUpIHtcbiAgICAgICAgZGVidWcoXCJGb3VuZCBpZ25vcmUgJW8gZnJvbSAlby5cIiwgaWdub3JlLmZpbGVwYXRoLCBkaXJuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbmZpZyxcbiAgICBpZ25vcmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZFJvb3RDb25maWcoZGlybmFtZSwgZW52TmFtZSwgY2FsbGVyKSB7XG4gIGNvbnN0IGZpbGVwYXRoID0gX3BhdGgoKS5kZWZhdWx0LnJlc29sdmUoZGlybmFtZSwgQkFCRUxfQ09ORklHX0pTX0ZJTEVOQU1FKTtcblxuICBjb25zdCBjb25mID0gcmVhZENvbmZpZyhmaWxlcGF0aCwgZW52TmFtZSwgY2FsbGVyKTtcblxuICBpZiAoY29uZikge1xuICAgIGRlYnVnKFwiRm91bmQgcm9vdCBjb25maWcgJW8gaW4gJG8uXCIsIEJBQkVMX0NPTkZJR19KU19GSUxFTkFNRSwgZGlybmFtZSk7XG4gIH1cblxuICByZXR1cm4gY29uZjtcbn1cblxuZnVuY3Rpb24gbG9hZENvbmZpZyhuYW1lLCBkaXJuYW1lLCBlbnZOYW1lLCBjYWxsZXIpIHtcbiAgY29uc3QgZmlsZXBhdGggPSBfcmVzb2x2ZSgpLmRlZmF1bHQuc3luYyhuYW1lLCB7XG4gICAgYmFzZWRpcjogZGlybmFtZVxuICB9KTtcblxuICBjb25zdCBjb25mID0gcmVhZENvbmZpZyhmaWxlcGF0aCwgZW52TmFtZSwgY2FsbGVyKTtcblxuICBpZiAoIWNvbmYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvbmZpZyBmaWxlICR7ZmlsZXBhdGh9IGNvbnRhaW5zIG5vIGNvbmZpZ3VyYXRpb24gZGF0YWApO1xuICB9XG5cbiAgZGVidWcoXCJMb2FkZWQgY29uZmlnICVvIGZyb20gJG8uXCIsIG5hbWUsIGRpcm5hbWUpO1xuICByZXR1cm4gY29uZjtcbn1cblxuZnVuY3Rpb24gcmVhZENvbmZpZyhmaWxlcGF0aCwgZW52TmFtZSwgY2FsbGVyKSB7XG4gIHJldHVybiBfcGF0aCgpLmRlZmF1bHQuZXh0bmFtZShmaWxlcGF0aCkgPT09IFwiLmpzXCIgPyByZWFkQ29uZmlnSlMoZmlsZXBhdGgsIHtcbiAgICBlbnZOYW1lLFxuICAgIGNhbGxlclxuICB9KSA6IHJlYWRDb25maWdKU09ONShmaWxlcGF0aCk7XG59XG5cbmNvbnN0IExPQURJTkdfQ09ORklHUyA9IG5ldyBTZXQoKTtcbmNvbnN0IHJlYWRDb25maWdKUyA9ICgwLCBfY2FjaGluZy5tYWtlU3Ryb25nQ2FjaGUpKChmaWxlcGF0aCwgY2FjaGUpID0+IHtcbiAgaWYgKCFfZnMoKS5kZWZhdWx0LmV4aXN0c1N5bmMoZmlsZXBhdGgpKSB7XG4gICAgY2FjaGUuZm9yZXZlcigpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKExPQURJTkdfQ09ORklHUy5oYXMoZmlsZXBhdGgpKSB7XG4gICAgY2FjaGUubmV2ZXIoKTtcbiAgICBkZWJ1ZyhcIkF1dG8taWdub3JpbmcgdXNhZ2Ugb2YgY29uZmlnICVvLlwiLCBmaWxlcGF0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGVwYXRoLFxuICAgICAgZGlybmFtZTogX3BhdGgoKS5kZWZhdWx0LmRpcm5hbWUoZmlsZXBhdGgpLFxuICAgICAgb3B0aW9uczoge31cbiAgICB9O1xuICB9XG5cbiAgbGV0IG9wdGlvbnM7XG5cbiAgdHJ5IHtcbiAgICBMT0FESU5HX0NPTkZJR1MuYWRkKGZpbGVwYXRoKTtcblxuICAgIGNvbnN0IGNvbmZpZ01vZHVsZSA9IHJlcXVpcmUoZmlsZXBhdGgpO1xuXG4gICAgb3B0aW9ucyA9IGNvbmZpZ01vZHVsZSAmJiBjb25maWdNb2R1bGUuX19lc01vZHVsZSA/IGNvbmZpZ01vZHVsZS5kZWZhdWx0IHx8IHVuZGVmaW5lZCA6IGNvbmZpZ01vZHVsZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBgJHtmaWxlcGF0aH06IEVycm9yIHdoaWxlIGxvYWRpbmcgY29uZmlnIC0gJHtlcnIubWVzc2FnZX1gO1xuICAgIHRocm93IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICBMT0FESU5HX0NPTkZJR1MuZGVsZXRlKGZpbGVwYXRoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMoKDAsIF9jb25maWdBcGkuZGVmYXVsdCkoY2FjaGUpKTtcbiAgICBpZiAoIWNhY2hlLmNvbmZpZ3VyZWQoKSkgdGhyb3dDb25maWdFcnJvcigpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZmlsZXBhdGh9OiBDb25maWd1cmF0aW9uIHNob3VsZCBiZSBhbiBleHBvcnRlZCBKYXZhU2NyaXB0IG9iamVjdC5gKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBhcHBlYXIgdG8gYmUgdXNpbmcgYW4gYXN5bmMgY29uZmlndXJhdGlvbiwgYCArIGB3aGljaCB5b3VyIGN1cnJlbnQgdmVyc2lvbiBvZiBCYWJlbCBkb2VzIG5vdCBzdXBwb3J0LiBgICsgYFdlIG1heSBhZGQgc3VwcG9ydCBmb3IgdGhpcyBpbiB0aGUgZnV0dXJlLCBgICsgYGJ1dCBpZiB5b3UncmUgb24gdGhlIG1vc3QgcmVjZW50IHZlcnNpb24gb2YgQGJhYmVsL2NvcmUgYW5kIHN0aWxsIGAgKyBgc2VlaW5nIHRoaXMgZXJyb3IsIHRoZW4geW91J2xsIG5lZWQgdG8gc3luY2hyb25vdXNseSByZXR1cm4geW91ciBjb25maWcuYCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZpbGVwYXRoLFxuICAgIGRpcm5hbWU6IF9wYXRoKCkuZGVmYXVsdC5kaXJuYW1lKGZpbGVwYXRoKSxcbiAgICBvcHRpb25zXG4gIH07XG59KTtcbmNvbnN0IHBhY2thZ2VUb0JhYmVsQ29uZmlnID0gKDAsIF9jYWNoaW5nLm1ha2VXZWFrQ2FjaGUpKGZpbGUgPT4ge1xuICBjb25zdCBiYWJlbCA9IGZpbGUub3B0aW9uc1tcImJhYmVsXCJdO1xuICBpZiAodHlwZW9mIGJhYmVsID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbDtcblxuICBpZiAodHlwZW9mIGJhYmVsICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkoYmFiZWwpIHx8IGJhYmVsID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2ZpbGUuZmlsZXBhdGh9OiAuYmFiZWwgcHJvcGVydHkgbXVzdCBiZSBhbiBvYmplY3RgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZmlsZXBhdGg6IGZpbGUuZmlsZXBhdGgsXG4gICAgZGlybmFtZTogZmlsZS5kaXJuYW1lLFxuICAgIG9wdGlvbnM6IGJhYmVsXG4gIH07XG59KTtcbmNvbnN0IHJlYWRDb25maWdKU09ONSA9ICgwLCBfdXRpbHMubWFrZVN0YXRpY0ZpbGVDYWNoZSkoKGZpbGVwYXRoLCBjb250ZW50KSA9PiB7XG4gIGxldCBvcHRpb25zO1xuXG4gIHRyeSB7XG4gICAgb3B0aW9ucyA9IF9qc29uKCkuZGVmYXVsdC5wYXJzZShjb250ZW50KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLm1lc3NhZ2UgPSBgJHtmaWxlcGF0aH06IEVycm9yIHdoaWxlIHBhcnNpbmcgY29uZmlnIC0gJHtlcnIubWVzc2FnZX1gO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIGlmICghb3B0aW9ucykgdGhyb3cgbmV3IEVycm9yKGAke2ZpbGVwYXRofTogTm8gY29uZmlnIGRldGVjdGVkYCk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2ZpbGVwYXRofTogQ29uZmlnIHJldHVybmVkIHR5cGVvZiAke3R5cGVvZiBvcHRpb25zfWApO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZmlsZXBhdGh9OiBFeHBlY3RlZCBjb25maWcgb2JqZWN0IGJ1dCBmb3VuZCBhcnJheWApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmaWxlcGF0aCxcbiAgICBkaXJuYW1lOiBfcGF0aCgpLmRlZmF1bHQuZGlybmFtZShmaWxlcGF0aCksXG4gICAgb3B0aW9uc1xuICB9O1xufSk7XG5jb25zdCByZWFkSWdub3JlQ29uZmlnID0gKDAsIF91dGlscy5tYWtlU3RhdGljRmlsZUNhY2hlKSgoZmlsZXBhdGgsIGNvbnRlbnQpID0+IHtcbiAgY29uc3QgaWdub3JlRGlyID0gX3BhdGgoKS5kZWZhdWx0LmRpcm5hbWUoZmlsZXBhdGgpO1xuXG4gIGNvbnN0IGlnbm9yZVBhdHRlcm5zID0gY29udGVudC5zcGxpdChcIlxcblwiKS5tYXAobGluZSA9PiBsaW5lLnJlcGxhY2UoLyMoLio/KSQvLCBcIlwiKS50cmltKCkpLmZpbHRlcihsaW5lID0+ICEhbGluZSk7XG5cbiAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGlnbm9yZVBhdHRlcm5zKSB7XG4gICAgaWYgKHBhdHRlcm5bMF0gPT09IFwiIVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5lZ2F0aW9uIG9mIGZpbGUgcGF0aHMgaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZpbGVwYXRoLFxuICAgIGRpcm5hbWU6IF9wYXRoKCkuZGVmYXVsdC5kaXJuYW1lKGZpbGVwYXRoKSxcbiAgICBpZ25vcmU6IGlnbm9yZVBhdHRlcm5zLm1hcChwYXR0ZXJuID0+ICgwLCBfcGF0dGVyblRvUmVnZXguZGVmYXVsdCkocGF0dGVybiwgaWdub3JlRGlyKSlcbiAgfTtcbn0pO1xuXG5mdW5jdGlvbiB0aHJvd0NvbmZpZ0Vycm9yKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoYFxcXG5DYWNoaW5nIHdhcyBsZWZ0IHVuY29uZmlndXJlZC4gQmFiZWwncyBwbHVnaW5zLCBwcmVzZXRzLCBhbmQgLmJhYmVscmMuanMgZmlsZXMgY2FuIGJlIGNvbmZpZ3VyZWRcbmZvciB2YXJpb3VzIHR5cGVzIG9mIGNhY2hpbmcsIHVzaW5nIHRoZSBmaXJzdCBwYXJhbSBvZiB0aGVpciBoYW5kbGVyIGZ1bmN0aW9uczpcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcGkpIHtcbiAgLy8gVGhlIEFQSSBleHBvc2VzIHRoZSBmb2xsb3dpbmc6XG5cbiAgLy8gQ2FjaGUgdGhlIHJldHVybmVkIHZhbHVlIGZvcmV2ZXIgYW5kIGRvbid0IGNhbGwgdGhpcyBmdW5jdGlvbiBhZ2Fpbi5cbiAgYXBpLmNhY2hlKHRydWUpO1xuXG4gIC8vIERvbid0IGNhY2hlIGF0IGFsbC4gTm90IHJlY29tbWVuZGVkIGJlY2F1c2UgaXQgd2lsbCBiZSB2ZXJ5IHNsb3cuXG4gIGFwaS5jYWNoZShmYWxzZSk7XG5cbiAgLy8gQ2FjaGVkIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiBzb21lIGZ1bmN0aW9uLiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSB2YWx1ZSBkaWZmZXJlbnQgZnJvbVxuICAvLyBhIHByZXZpb3VzbHktZW5jb3VudGVyZWQgdmFsdWUsIHRoZSBwbHVnaW5zIHdpbGwgcmUtZXZhbHVhdGUuXG4gIHZhciBlbnYgPSBhcGkuY2FjaGUoKCkgPT4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpO1xuXG4gIC8vIElmIHRlc3RpbmcgZm9yIGEgc3BlY2lmaWMgZW52LCB3ZSByZWNvbW1lbmQgc3BlY2lmaWNzIHRvIGF2b2lkIGluc3RhbnRpYXRpbmcgYSBwbHVnaW4gZm9yXG4gIC8vIGFueSBwb3NzaWJsZSBOT0RFX0VOViB2YWx1ZSB0aGF0IG1pZ2h0IGNvbWUgdXAgZHVyaW5nIHBsdWdpbiBleGVjdXRpb24uXG4gIHZhciBpc1Byb2QgPSBhcGkuY2FjaGUoKCkgPT4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKTtcblxuICAvLyAuY2FjaGUoZm4pIHdpbGwgcGVyZm9ybSBhIGxpbmVhciBzZWFyY2ggdGhvdWdoIGluc3RhbmNlcyB0byBmaW5kIHRoZSBtYXRjaGluZyBwbHVnaW4gYmFzZWRcbiAgLy8gYmFzZWQgb24gcHJldmlvdXMgaW5zdGFudGlhdGVkIHBsdWdpbnMuIElmIHlvdSB3YW50IHRvIHJlY3JlYXRlIHRoZSBwbHVnaW4gYW5kIGRpc2NhcmQgdGhlXG4gIC8vIHByZXZpb3VzIGluc3RhbmNlIHdoZW5ldmVyIHNvbWV0aGluZyBjaGFuZ2VzLCB5b3UgbWF5IHVzZTpcbiAgdmFyIGlzUHJvZCA9IGFwaS5jYWNoZS5pbnZhbGlkYXRlKCgpID0+IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIik7XG5cbiAgLy8gTm90ZSwgd2UgYWxzbyBleHBvc2UgdGhlIGZvbGxvd2luZyBtb3JlLXZlcmJvc2UgdmVyc2lvbnMgb2YgdGhlIGFib3ZlIGV4YW1wbGVzOlxuICBhcGkuY2FjaGUuZm9yZXZlcigpOyAvLyBhcGkuY2FjaGUodHJ1ZSlcbiAgYXBpLmNhY2hlLm5ldmVyKCk7ICAgLy8gYXBpLmNhY2hlKGZhbHNlKVxuICBhcGkuY2FjaGUudXNpbmcoZm4pOyAvLyBhcGkuY2FjaGUoZm4pXG5cbiAgLy8gUmV0dXJuIHRoZSB2YWx1ZSB0aGF0IHdpbGwgYmUgY2FjaGVkLlxuICByZXR1cm4geyB9O1xufTtgKTtcbn0iXX0=