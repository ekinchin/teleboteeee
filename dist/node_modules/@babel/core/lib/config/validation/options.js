"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validate = validate;

var _plugin = _interopRequireDefault(require("../plugin"));

var _removed = _interopRequireDefault(require("./removed"));

var _optionAssertions = require("./option-assertions");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

const ROOT_VALIDATORS = {
  cwd: _optionAssertions.assertString,
  root: _optionAssertions.assertString,
  rootMode: _optionAssertions.assertRootMode,
  configFile: _optionAssertions.assertConfigFileSearch,
  caller: _optionAssertions.assertCallerMetadata,
  filename: _optionAssertions.assertString,
  filenameRelative: _optionAssertions.assertString,
  code: _optionAssertions.assertBoolean,
  ast: _optionAssertions.assertBoolean,
  envName: _optionAssertions.assertString
};
const BABELRC_VALIDATORS = {
  babelrc: _optionAssertions.assertBoolean,
  babelrcRoots: _optionAssertions.assertBabelrcSearch
};
const NONPRESET_VALIDATORS = {
  extends: _optionAssertions.assertString,
  ignore: _optionAssertions.assertIgnoreList,
  only: _optionAssertions.assertIgnoreList
};
const COMMON_VALIDATORS = {
  inputSourceMap: _optionAssertions.assertInputSourceMap,
  presets: _optionAssertions.assertPluginList,
  plugins: _optionAssertions.assertPluginList,
  passPerPreset: _optionAssertions.assertBoolean,
  env: assertEnvSet,
  overrides: assertOverridesList,
  test: _optionAssertions.assertConfigApplicableTest,
  include: _optionAssertions.assertConfigApplicableTest,
  exclude: _optionAssertions.assertConfigApplicableTest,
  retainLines: _optionAssertions.assertBoolean,
  comments: _optionAssertions.assertBoolean,
  shouldPrintComment: _optionAssertions.assertFunction,
  compact: _optionAssertions.assertCompact,
  minified: _optionAssertions.assertBoolean,
  auxiliaryCommentBefore: _optionAssertions.assertString,
  auxiliaryCommentAfter: _optionAssertions.assertString,
  sourceType: _optionAssertions.assertSourceType,
  wrapPluginVisitorMethod: _optionAssertions.assertFunction,
  highlightCode: _optionAssertions.assertBoolean,
  sourceMaps: _optionAssertions.assertSourceMaps,
  sourceMap: _optionAssertions.assertSourceMaps,
  sourceFileName: _optionAssertions.assertString,
  sourceRoot: _optionAssertions.assertString,
  getModuleId: _optionAssertions.assertFunction,
  moduleRoot: _optionAssertions.assertString,
  moduleIds: _optionAssertions.assertBoolean,
  moduleId: _optionAssertions.assertString,
  parserOpts: _optionAssertions.assertObject,
  generatorOpts: _optionAssertions.assertObject
};

function getSource(loc) {
  return loc.type === "root" ? loc.source : getSource(loc.parent);
}

function validate(type, opts) {
  return validateNested({
    type: "root",
    source: type
  }, opts);
}

function validateNested(loc, opts) {
  const type = getSource(loc);
  assertNoDuplicateSourcemap(opts);
  Object.keys(opts).forEach(key => {
    const optLoc = {
      type: "option",
      name: key,
      parent: loc
    };

    if (type === "preset" && NONPRESET_VALIDATORS[key]) {
      throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in preset options`);
    }

    if (type !== "arguments" && ROOT_VALIDATORS[key]) {
      throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options`);
    }

    if (type !== "arguments" && type !== "configfile" && BABELRC_VALIDATORS[key]) {
      if (type === "babelrcfile" || type === "extendsfile") {
        throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, ` + `or babel.config.js/config file options`);
      }

      throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options, or babel.config.js/config file options`);
    }

    const validator = COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError;
    validator(optLoc, opts[key]);
  });
  return opts;
}

function throwUnknownError(loc) {
  const key = loc.name;

  if (_removed.default[key]) {
    const {
      message,
      version = 5
    } = _removed.default[key];
    throw new ReferenceError(`Using removed Babel ${version} option: ${(0, _optionAssertions.msg)(loc)} - ${message}`);
  } else {
    const unknownOptErr = `Unknown option: ${(0, _optionAssertions.msg)(loc)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`;
    throw new ReferenceError(unknownOptErr);
  }
}

function has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

function assertNoDuplicateSourcemap(opts) {
  if (has(opts, "sourceMap") && has(opts, "sourceMaps")) {
    throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
  }
}

function assertEnvSet(loc, value) {
  if (loc.parent.type === "env") {
    throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside of another .env block`);
  }

  const parent = loc.parent;
  const obj = (0, _optionAssertions.assertObject)(loc, value);

  if (obj) {
    for (const envName of Object.keys(obj)) {
      const env = (0, _optionAssertions.assertObject)((0, _optionAssertions.access)(loc, envName), obj[envName]);
      if (!env) continue;
      const envLoc = {
        type: "env",
        name: envName,
        parent
      };
      validateNested(envLoc, env);
    }
  }

  return obj;
}

function assertOverridesList(loc, value) {
  if (loc.parent.type === "env") {
    throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .env block`);
  }

  if (loc.parent.type === "overrides") {
    throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .overrides block`);
  }

  const parent = loc.parent;
  const arr = (0, _optionAssertions.assertArray)(loc, value);

  if (arr) {
    for (const [index, item] of arr.entries()) {
      const objLoc = (0, _optionAssertions.access)(loc, index);
      const env = (0, _optionAssertions.assertObject)(objLoc, item);
      if (!env) throw new Error(`${(0, _optionAssertions.msg)(objLoc)} must be an object`);
      const overridesLoc = {
        type: "overrides",
        index,
        parent
      };
      validateNested(overridesLoc, env);
    }
  }

  return arr;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9AYmFiZWwvY29yZS9saWIvY29uZmlnL3ZhbGlkYXRpb24vb3B0aW9ucy5qcyJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInZhbGlkYXRlIiwiX3BsdWdpbiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJyZXF1aXJlIiwiX3JlbW92ZWQiLCJfb3B0aW9uQXNzZXJ0aW9ucyIsIm9iaiIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiUk9PVF9WQUxJREFUT1JTIiwiY3dkIiwiYXNzZXJ0U3RyaW5nIiwicm9vdCIsInJvb3RNb2RlIiwiYXNzZXJ0Um9vdE1vZGUiLCJjb25maWdGaWxlIiwiYXNzZXJ0Q29uZmlnRmlsZVNlYXJjaCIsImNhbGxlciIsImFzc2VydENhbGxlck1ldGFkYXRhIiwiZmlsZW5hbWUiLCJmaWxlbmFtZVJlbGF0aXZlIiwiY29kZSIsImFzc2VydEJvb2xlYW4iLCJhc3QiLCJlbnZOYW1lIiwiQkFCRUxSQ19WQUxJREFUT1JTIiwiYmFiZWxyYyIsImJhYmVscmNSb290cyIsImFzc2VydEJhYmVscmNTZWFyY2giLCJOT05QUkVTRVRfVkFMSURBVE9SUyIsImV4dGVuZHMiLCJpZ25vcmUiLCJhc3NlcnRJZ25vcmVMaXN0Iiwib25seSIsIkNPTU1PTl9WQUxJREFUT1JTIiwiaW5wdXRTb3VyY2VNYXAiLCJhc3NlcnRJbnB1dFNvdXJjZU1hcCIsInByZXNldHMiLCJhc3NlcnRQbHVnaW5MaXN0IiwicGx1Z2lucyIsInBhc3NQZXJQcmVzZXQiLCJlbnYiLCJhc3NlcnRFbnZTZXQiLCJvdmVycmlkZXMiLCJhc3NlcnRPdmVycmlkZXNMaXN0IiwidGVzdCIsImFzc2VydENvbmZpZ0FwcGxpY2FibGVUZXN0IiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJyZXRhaW5MaW5lcyIsImNvbW1lbnRzIiwic2hvdWxkUHJpbnRDb21tZW50IiwiYXNzZXJ0RnVuY3Rpb24iLCJjb21wYWN0IiwiYXNzZXJ0Q29tcGFjdCIsIm1pbmlmaWVkIiwiYXV4aWxpYXJ5Q29tbWVudEJlZm9yZSIsImF1eGlsaWFyeUNvbW1lbnRBZnRlciIsInNvdXJjZVR5cGUiLCJhc3NlcnRTb3VyY2VUeXBlIiwid3JhcFBsdWdpblZpc2l0b3JNZXRob2QiLCJoaWdobGlnaHRDb2RlIiwic291cmNlTWFwcyIsImFzc2VydFNvdXJjZU1hcHMiLCJzb3VyY2VNYXAiLCJzb3VyY2VGaWxlTmFtZSIsInNvdXJjZVJvb3QiLCJnZXRNb2R1bGVJZCIsIm1vZHVsZVJvb3QiLCJtb2R1bGVJZHMiLCJtb2R1bGVJZCIsInBhcnNlck9wdHMiLCJhc3NlcnRPYmplY3QiLCJnZW5lcmF0b3JPcHRzIiwiZ2V0U291cmNlIiwibG9jIiwidHlwZSIsInNvdXJjZSIsInBhcmVudCIsIm9wdHMiLCJ2YWxpZGF0ZU5lc3RlZCIsImFzc2VydE5vRHVwbGljYXRlU291cmNlbWFwIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJvcHRMb2MiLCJuYW1lIiwiRXJyb3IiLCJtc2ciLCJ2YWxpZGF0b3IiLCJ0aHJvd1Vua25vd25FcnJvciIsIm1lc3NhZ2UiLCJ2ZXJzaW9uIiwiUmVmZXJlbmNlRXJyb3IiLCJ1bmtub3duT3B0RXJyIiwiaGFzIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYWNjZXNzIiwiZW52TG9jIiwiYXJyIiwiYXNzZXJ0QXJyYXkiLCJpbmRleCIsIml0ZW0iLCJlbnRyaWVzIiwib2JqTG9jIiwib3ZlcnJpZGVzTG9jIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQUEsTUFBTSxDQUFDQyxjQUFQLENBQXNCQyxPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUMzQ0MsRUFBQUEsS0FBSyxFQUFFO0FBRG9DLENBQTdDO0FBR0FELE9BQU8sQ0FBQ0UsUUFBUixHQUFtQkEsUUFBbkI7O0FBRUEsSUFBSUMsT0FBTyxHQUFHQyxzQkFBc0IsQ0FBQ0MsT0FBTyxDQUFDLFdBQUQsQ0FB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QUFKLENBQVcsR0FBRSxDQUFDLEdBQUdsRixpQkFBaUIsQ0FBQ21GLEdBQXRCLEVBQTJCa0IsTUFBM0IsQ0FBbUMsb0JBQWhELENBQU47QUFDVixZQUFNQyxZQUFZLEdBQUc7QUFDbkIvQixRQUFBQSxJQUFJLEVBQUUsV0FEYTtBQUVuQjJCLFFBQUFBLEtBRm1CO0FBR25CekIsUUFBQUE7QUFIbUIsT0FBckI7QUFLQUUsTUFBQUEsY0FBYyxDQUFDMkIsWUFBRCxFQUFlbEUsR0FBZixDQUFkO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPNEQsR0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG5cbnZhciBfcGx1Z2luID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vcGx1Z2luXCIpKTtcblxudmFyIF9yZW1vdmVkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9yZW1vdmVkXCIpKTtcblxudmFyIF9vcHRpb25Bc3NlcnRpb25zID0gcmVxdWlyZShcIi4vb3B0aW9uLWFzc2VydGlvbnNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IFJPT1RfVkFMSURBVE9SUyA9IHtcbiAgY3dkOiBfb3B0aW9uQXNzZXJ0aW9ucy5hc3NlcnRTdHJpbmcsXG4gIHJvb3Q6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydFN0cmluZyxcbiAgcm9vdE1vZGU6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydFJvb3RNb2RlLFxuICBjb25maWdGaWxlOiBfb3B0aW9uQXNzZXJ0aW9ucy5hc3NlcnRDb25maWdGaWxlU2VhcmNoLFxuICBjYWxsZXI6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydENhbGxlck1ldGFkYXRhLFxuICBmaWxlbmFtZTogX29wdGlvbkFzc2VydGlvbnMuYXNzZXJ0U3RyaW5nLFxuICBmaWxlbmFtZVJlbGF0aXZlOiBfb3B0aW9uQXNzZXJ0aW9ucy5hc3NlcnRTdHJpbmcsXG4gIGNvZGU6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydEJvb2xlYW4sXG4gIGFzdDogX29wdGlvbkFzc2VydGlvbnMuYXNzZXJ0Qm9vbGVhbixcbiAgZW52TmFtZTogX29wdGlvbkFzc2VydGlvbnMuYXNzZXJ0U3RyaW5nXG59O1xuY29uc3QgQkFCRUxSQ19WQUxJREFUT1JTID0ge1xuICBiYWJlbHJjOiBfb3B0aW9uQXNzZXJ0aW9ucy5hc3NlcnRCb29sZWFuLFxuICBiYWJlbHJjUm9vdHM6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydEJhYmVscmNTZWFyY2hcbn07XG5jb25zdCBOT05QUkVTRVRfVkFMSURBVE9SUyA9IHtcbiAgZXh0ZW5kczogX29wdGlvbkFzc2VydGlvbnMuYXNzZXJ0U3RyaW5nLFxuICBpZ25vcmU6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydElnbm9yZUxpc3QsXG4gIG9ubHk6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydElnbm9yZUxpc3Rcbn07XG5jb25zdCBDT01NT05fVkFMSURBVE9SUyA9IHtcbiAgaW5wdXRTb3VyY2VNYXA6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydElucHV0U291cmNlTWFwLFxuICBwcmVzZXRzOiBfb3B0aW9uQXNzZXJ0aW9ucy5hc3NlcnRQbHVnaW5MaXN0LFxuICBwbHVnaW5zOiBfb3B0aW9uQXNzZXJ0aW9ucy5hc3NlcnRQbHVnaW5MaXN0LFxuICBwYXNzUGVyUHJlc2V0OiBfb3B0aW9uQXNzZXJ0aW9ucy5hc3NlcnRCb29sZWFuLFxuICBlbnY6IGFzc2VydEVudlNldCxcbiAgb3ZlcnJpZGVzOiBhc3NlcnRPdmVycmlkZXNMaXN0LFxuICB0ZXN0OiBfb3B0aW9uQXNzZXJ0aW9ucy5hc3NlcnRDb25maWdBcHBsaWNhYmxlVGVzdCxcbiAgaW5jbHVkZTogX29wdGlvbkFzc2VydGlvbnMuYXNzZXJ0Q29uZmlnQXBwbGljYWJsZVRlc3QsXG4gIGV4Y2x1ZGU6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydENvbmZpZ0FwcGxpY2FibGVUZXN0LFxuICByZXRhaW5MaW5lczogX29wdGlvbkFzc2VydGlvbnMuYXNzZXJ0Qm9vbGVhbixcbiAgY29tbWVudHM6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydEJvb2xlYW4sXG4gIHNob3VsZFByaW50Q29tbWVudDogX29wdGlvbkFzc2VydGlvbnMuYXNzZXJ0RnVuY3Rpb24sXG4gIGNvbXBhY3Q6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydENvbXBhY3QsXG4gIG1pbmlmaWVkOiBfb3B0aW9uQXNzZXJ0aW9ucy5hc3NlcnRCb29sZWFuLFxuICBhdXhpbGlhcnlDb21tZW50QmVmb3JlOiBfb3B0aW9uQXNzZXJ0aW9ucy5hc3NlcnRTdHJpbmcsXG4gIGF1eGlsaWFyeUNvbW1lbnRBZnRlcjogX29wdGlvbkFzc2VydGlvbnMuYXNzZXJ0U3RyaW5nLFxuICBzb3VyY2VUeXBlOiBfb3B0aW9uQXNzZXJ0aW9ucy5hc3NlcnRTb3VyY2VUeXBlLFxuICB3cmFwUGx1Z2luVmlzaXRvck1ldGhvZDogX29wdGlvbkFzc2VydGlvbnMuYXNzZXJ0RnVuY3Rpb24sXG4gIGhpZ2hsaWdodENvZGU6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydEJvb2xlYW4sXG4gIHNvdXJjZU1hcHM6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydFNvdXJjZU1hcHMsXG4gIHNvdXJjZU1hcDogX29wdGlvbkFzc2VydGlvbnMuYXNzZXJ0U291cmNlTWFwcyxcbiAgc291cmNlRmlsZU5hbWU6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydFN0cmluZyxcbiAgc291cmNlUm9vdDogX29wdGlvbkFzc2VydGlvbnMuYXNzZXJ0U3RyaW5nLFxuICBnZXRNb2R1bGVJZDogX29wdGlvbkFzc2VydGlvbnMuYXNzZXJ0RnVuY3Rpb24sXG4gIG1vZHVsZVJvb3Q6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydFN0cmluZyxcbiAgbW9kdWxlSWRzOiBfb3B0aW9uQXNzZXJ0aW9ucy5hc3NlcnRCb29sZWFuLFxuICBtb2R1bGVJZDogX29wdGlvbkFzc2VydGlvbnMuYXNzZXJ0U3RyaW5nLFxuICBwYXJzZXJPcHRzOiBfb3B0aW9uQXNzZXJ0aW9ucy5hc3NlcnRPYmplY3QsXG4gIGdlbmVyYXRvck9wdHM6IF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydE9iamVjdFxufTtcblxuZnVuY3Rpb24gZ2V0U291cmNlKGxvYykge1xuICByZXR1cm4gbG9jLnR5cGUgPT09IFwicm9vdFwiID8gbG9jLnNvdXJjZSA6IGdldFNvdXJjZShsb2MucGFyZW50KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGUodHlwZSwgb3B0cykge1xuICByZXR1cm4gdmFsaWRhdGVOZXN0ZWQoe1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIHNvdXJjZTogdHlwZVxuICB9LCBvcHRzKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOZXN0ZWQobG9jLCBvcHRzKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRTb3VyY2UobG9jKTtcbiAgYXNzZXJ0Tm9EdXBsaWNhdGVTb3VyY2VtYXAob3B0cyk7XG4gIE9iamVjdC5rZXlzKG9wdHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCBvcHRMb2MgPSB7XG4gICAgICB0eXBlOiBcIm9wdGlvblwiLFxuICAgICAgbmFtZToga2V5LFxuICAgICAgcGFyZW50OiBsb2NcbiAgICB9O1xuXG4gICAgaWYgKHR5cGUgPT09IFwicHJlc2V0XCIgJiYgTk9OUFJFU0VUX1ZBTElEQVRPUlNba2V5XSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAkeygwLCBfb3B0aW9uQXNzZXJ0aW9ucy5tc2cpKG9wdExvYyl9IGlzIG5vdCBhbGxvd2VkIGluIHByZXNldCBvcHRpb25zYCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgIT09IFwiYXJndW1lbnRzXCIgJiYgUk9PVF9WQUxJREFUT1JTW2tleV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHsoMCwgX29wdGlvbkFzc2VydGlvbnMubXNnKShvcHRMb2MpfSBpcyBvbmx5IGFsbG93ZWQgaW4gcm9vdCBwcm9ncmFtbWF0aWMgb3B0aW9uc2ApO1xuICAgIH1cblxuICAgIGlmICh0eXBlICE9PSBcImFyZ3VtZW50c1wiICYmIHR5cGUgIT09IFwiY29uZmlnZmlsZVwiICYmIEJBQkVMUkNfVkFMSURBVE9SU1trZXldKSB7XG4gICAgICBpZiAodHlwZSA9PT0gXCJiYWJlbHJjZmlsZVwiIHx8IHR5cGUgPT09IFwiZXh0ZW5kc2ZpbGVcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7KDAsIF9vcHRpb25Bc3NlcnRpb25zLm1zZykob3B0TG9jKX0gaXMgbm90IGFsbG93ZWQgaW4gLmJhYmVscmMgb3IgXCJleHRlbmRzXCJlZCBmaWxlcywgb25seSBpbiByb290IHByb2dyYW1tYXRpYyBvcHRpb25zLCBgICsgYG9yIGJhYmVsLmNvbmZpZy5qcy9jb25maWcgZmlsZSBvcHRpb25zYCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHsoMCwgX29wdGlvbkFzc2VydGlvbnMubXNnKShvcHRMb2MpfSBpcyBvbmx5IGFsbG93ZWQgaW4gcm9vdCBwcm9ncmFtbWF0aWMgb3B0aW9ucywgb3IgYmFiZWwuY29uZmlnLmpzL2NvbmZpZyBmaWxlIG9wdGlvbnNgKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZGF0b3IgPSBDT01NT05fVkFMSURBVE9SU1trZXldIHx8IE5PTlBSRVNFVF9WQUxJREFUT1JTW2tleV0gfHwgQkFCRUxSQ19WQUxJREFUT1JTW2tleV0gfHwgUk9PVF9WQUxJREFUT1JTW2tleV0gfHwgdGhyb3dVbmtub3duRXJyb3I7XG4gICAgdmFsaWRhdG9yKG9wdExvYywgb3B0c1trZXldKTtcbiAgfSk7XG4gIHJldHVybiBvcHRzO1xufVxuXG5mdW5jdGlvbiB0aHJvd1Vua25vd25FcnJvcihsb2MpIHtcbiAgY29uc3Qga2V5ID0gbG9jLm5hbWU7XG5cbiAgaWYgKF9yZW1vdmVkLmRlZmF1bHRba2V5XSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICB2ZXJzaW9uID0gNVxuICAgIH0gPSBfcmVtb3ZlZC5kZWZhdWx0W2tleV07XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKGBVc2luZyByZW1vdmVkIEJhYmVsICR7dmVyc2lvbn0gb3B0aW9uOiAkeygwLCBfb3B0aW9uQXNzZXJ0aW9ucy5tc2cpKGxvYyl9IC0gJHttZXNzYWdlfWApO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHVua25vd25PcHRFcnIgPSBgVW5rbm93biBvcHRpb246ICR7KDAsIF9vcHRpb25Bc3NlcnRpb25zLm1zZykobG9jKX0uIENoZWNrIG91dCBodHRwczovL2JhYmVsanMuaW8vZG9jcy9lbi9iYWJlbC1jb3JlLyNvcHRpb25zIGZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IG9wdGlvbnMuYDtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IodW5rbm93bk9wdEVycik7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5mdW5jdGlvbiBhc3NlcnROb0R1cGxpY2F0ZVNvdXJjZW1hcChvcHRzKSB7XG4gIGlmIChoYXMob3B0cywgXCJzb3VyY2VNYXBcIikgJiYgaGFzKG9wdHMsIFwic291cmNlTWFwc1wiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIi5zb3VyY2VNYXAgaXMgYW4gYWxpYXMgZm9yIC5zb3VyY2VNYXBzLCBjYW5ub3QgdXNlIGJvdGhcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0RW52U2V0KGxvYywgdmFsdWUpIHtcbiAgaWYgKGxvYy5wYXJlbnQudHlwZSA9PT0gXCJlbnZcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsoMCwgX29wdGlvbkFzc2VydGlvbnMubXNnKShsb2MpfSBpcyBub3QgYWxsb3dlZCBpbnNpZGUgb2YgYW5vdGhlciAuZW52IGJsb2NrYCk7XG4gIH1cblxuICBjb25zdCBwYXJlbnQgPSBsb2MucGFyZW50O1xuICBjb25zdCBvYmogPSAoMCwgX29wdGlvbkFzc2VydGlvbnMuYXNzZXJ0T2JqZWN0KShsb2MsIHZhbHVlKTtcblxuICBpZiAob2JqKSB7XG4gICAgZm9yIChjb25zdCBlbnZOYW1lIG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgIGNvbnN0IGVudiA9ICgwLCBfb3B0aW9uQXNzZXJ0aW9ucy5hc3NlcnRPYmplY3QpKCgwLCBfb3B0aW9uQXNzZXJ0aW9ucy5hY2Nlc3MpKGxvYywgZW52TmFtZSksIG9ialtlbnZOYW1lXSk7XG4gICAgICBpZiAoIWVudikgY29udGludWU7XG4gICAgICBjb25zdCBlbnZMb2MgPSB7XG4gICAgICAgIHR5cGU6IFwiZW52XCIsXG4gICAgICAgIG5hbWU6IGVudk5hbWUsXG4gICAgICAgIHBhcmVudFxuICAgICAgfTtcbiAgICAgIHZhbGlkYXRlTmVzdGVkKGVudkxvYywgZW52KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRPdmVycmlkZXNMaXN0KGxvYywgdmFsdWUpIHtcbiAgaWYgKGxvYy5wYXJlbnQudHlwZSA9PT0gXCJlbnZcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsoMCwgX29wdGlvbkFzc2VydGlvbnMubXNnKShsb2MpfSBpcyBub3QgYWxsb3dlZCBpbnNpZGUgYW4gLmVudiBibG9ja2ApO1xuICB9XG5cbiAgaWYgKGxvYy5wYXJlbnQudHlwZSA9PT0gXCJvdmVycmlkZXNcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHsoMCwgX29wdGlvbkFzc2VydGlvbnMubXNnKShsb2MpfSBpcyBub3QgYWxsb3dlZCBpbnNpZGUgYW4gLm92ZXJyaWRlcyBibG9ja2ApO1xuICB9XG5cbiAgY29uc3QgcGFyZW50ID0gbG9jLnBhcmVudDtcbiAgY29uc3QgYXJyID0gKDAsIF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydEFycmF5KShsb2MsIHZhbHVlKTtcblxuICBpZiAoYXJyKSB7XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGl0ZW1dIG9mIGFyci5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IG9iakxvYyA9ICgwLCBfb3B0aW9uQXNzZXJ0aW9ucy5hY2Nlc3MpKGxvYywgaW5kZXgpO1xuICAgICAgY29uc3QgZW52ID0gKDAsIF9vcHRpb25Bc3NlcnRpb25zLmFzc2VydE9iamVjdCkob2JqTG9jLCBpdGVtKTtcbiAgICAgIGlmICghZW52KSB0aHJvdyBuZXcgRXJyb3IoYCR7KDAsIF9vcHRpb25Bc3NlcnRpb25zLm1zZykob2JqTG9jKX0gbXVzdCBiZSBhbiBvYmplY3RgKTtcbiAgICAgIGNvbnN0IG92ZXJyaWRlc0xvYyA9IHtcbiAgICAgICAgdHlwZTogXCJvdmVycmlkZXNcIixcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHBhcmVudFxuICAgICAgfTtcbiAgICAgIHZhbGlkYXRlTmVzdGVkKG92ZXJyaWRlc0xvYywgZW52KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyO1xufSJdfQ==